# Class 3

## Overview
The following exercises will help you undersand the binary behind all of the characters we use. You will also learn about a very important binary operation, XOR. We'll also look at an encryption scheme that uses XOR, the One-Time Pad, and we'll perform some attacks against some poorly encrypted strings.


## Binary and XOR
Everything represented on your computer is just stored as bits, 1s and 0s. Let's take a look at some binary numbers:

![binary-1](images/binary-1.png)

These are what the numbers actually are; everything else is just a lie. Even letters are just binary:

![binary-2](images/binary-2.png)

And to convert back to ASCII:

![binary-3](images/binary-3.png)

With binary operators we can just deal with the decimal representations, but it's important to understand what's happening under the hood.

Here's a truth table for the binary XOR (exclusive-or) operation:

| A     | B     | A XOR B |
| ----- | ----- | ------- |
| 1     | 1     | 0       |
| 1     | 0     | 1	  |
| 0     | 1     | 1	  |
| 0     | 0     | 0	  |

And here's how to XOR two numbers in Python ('^' is the binary XOR operator in Python). Pay attenion to what is happening at the binary level:

![binary-4](images/binary-4.png)

>**Without coding it, what is 1100 ^ 0101? What about 8 ^ 11?**

Now, how do we XOR two strings? Well, we just have to convert them to numbers first! We saw in the previous exercise how to do this, but there is an easier way using the pycrypto Python module. We can also convert from the number back to the bytes:

![xor-1](images/xor-1.png)

Now, you have everything you need to write your own XOR function that takes in two strings and returns the XOR of them. If you want to attempt this, it would be a great coding exercise, but I'm going to show you a quick and easy-to-use XOR function from **pwntools**:

![xor-2](images/xor-2.png)

The pwntools xor function will cycle the shorter string over the longer one.


## Transformations
So far, we've seen a few ways to represent strings:
* ASCII
* Integer
* Hex Digest
And we'll add one more:
* Byte Array
A byte array of a string is just an array of the ordinal values of the characters. For example, they byte array of **"abc"** is **[ord('a'), ord('b'), ord('c')]**.

It's very important to be able to convert between these formats:
```python
# These are the 12 1-line transformations that are most useful to crypto CTF problems

#THIS IS THE PYTHON 2 VERSION
#in every CTF or crypto session this line is my first include
from Crypto.Util.number import *

#Our four formats are plaintext (ASCII), hex digest, integer, and byte array
pt="this is plaintext"

#1) ASCII to HEX
hexdigest = pt.encode('hex')
#2) HEX to ASCII
hexdigest.decode('hex')

#3) ASCII to Integer
int_pt = bytes_to_long(pt)
#4) Integer to ASCII
long_to_bytes(int_pt)

#5) Integer to hex
format(int_pt, 'x')
#6) hex to Integer
int(hexdigest, 16)

#7) ASCII to byte array
pt_as_bytes = map(ord, pt)
#8) byte array to ASCII
"".join(map(chr, pt_as_bytes))

#9) byte array to hex
"".join(map(lambda x: hex(x)[2:], pt_as_bytes))

#10) hex to byte array
[int(hexdigest[i:i+2], 16) for i in range(0, len(hexdigest), 2)]

#11) byte array to int
bytes_to_long("".join(map(chr, pt_as_bytes)))

#12) int to byte array
map(ord, long_to_bytes(int_pt))
```


