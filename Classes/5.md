# Class 5 RSA

## Overview

RSA is our first asymmetric key encryption algorithm, meaning the key used for encryption is different than the key used for decryption. In order to encrypt/decrypt with RSA and pull off the various attacks on this algorithm, we need to be comfortable with modular arithmetic in python first. 


## Modular Arithmetic
**A Note on Notation**  
> &#8484; refers to the set of integers.
>
> &#8477; refers to the set of real numbers.

**Quotient Remainder Theorem** 
> For every integer a and every positive integer b, there exists
> q,r &isin; &#8484; such that 
>
> a = b&sdot;q + r  0 &le; r &lt; b.
> So when we take a (mod b), we get r. 

#### Arithmetic Properties 
**Addition of two integers (mod n)**  
> a + b (mod n) &equiv; (a (mod n) + b (mod n)) (mod n) 

**Multiplication of two integers (mod n)** 

> a &sdot; b (mod n) &equiv; (a (mod n) &sdot; b (mod n)) (mod n) 

**Subtraction (or the Additive Inverse)**  
When we are dealing with real numbers, and we compute a - b, we are also doing
a + (-b). But negative numbers aren't in our range from 0 &le; x &lt; n, where
n is our modulus. If 0 &le; b &lt; n, then -b = n - b, and instead of 
subtracting we can add (-b). 

If we take n = 30, and we take powers of 29 (mod n), what pattern do you see? 
 
#### Multiplicative Inverse, GCD, and Euler's Totient Function 
The Greatest Common Divisor (GCD) 
> The GCD(a, b) a, b &isin; &#8484; is the largest integer that divides 
> both a and b. 

To calculate the GCD in python we can use 
```python 
#this is a must have when doing a Crypto Challenge
from Crypto.Util.number import *
a = 6
b = 2 
print(GCD(a, b)) 
> 2
```
The calculation of the GCD using this function is done in O(log(N)) time, where
N is the size of the number (in bits). This fact is extremely powerful since 
RSA uses massive numbers, and we have a very finite amount of time to 
crack these CTF problems. 

Here's a fact about the GCD of two numbers. 
> For a, b &isin; &#8484; we can find x,y &isin; &#8484; such that 
> 
> x&sdot;a + y&sdot;b = GCD(a, b) 

This fact matters to calculating the multiplicative inverse of a mod n. This 
inverse, which we will call s, is a number such that 
> s&sdot;a &equiv; 1 (mod n) 
Now, suppose we have integers a and b, and the GCD(a, b) = 1. 

We can then find x and y that satisfies
> x&sdot;a + y&sdot;b = 1

Now, what's the inverse of a mod b? 

We take both sides of our equation mod b. 

> x&sdot;a (mod b) + y&sdot;b (mod b) &equiv; 1 (mod b) 
> 
> x&sdot;a (mod b) + 0 &equiv; 1 (mod b) 

So x is our inverse! 

Okay, so how do we compute it in python? 

```python 
from Crypto.Util.number import *
a = 7 # the number we want to find the inverse of  
b = 30 # our modulus 
print(inverse(7, 30)) 
> 13
a = 6
b = 12 
print(inverse(6, 12)) 
> 1 # ??? Why is this the case???  
```

##### The inverse only exists if GCD(a, b) == 1.

What is Euler's Totient Function? 
> Euler's Totient Function, denoted by &Phi;(n), is how many numbers less than
> n that are relatively prime to n. 

What does relatively prime mean? 
> Two numbers are relatively prime if they share no common factors, so their 
> GCD is 1

In RSA, we will mainly be concerned about &Phi;(n) where n is a prime, and 
the there are n - 1 integers less than n that do not share a factor with 
n. 

So &Phi;(n) = n - 1

Also &Phi;(p&sdot;q) = (p - 1)&sdot;(q - 1), when p and q are prime.  

**Euler's Theorem** 
> For any integer a, a<sup>&Phi;(n)</sup> (mod n) = 1

^^^This is huge, it's the reason that RSA works!

#### Modular Arithmetic Challenge: Crack the Affine Cipher
The Affine Cipher is a function that maps plaintext characters to ciphertext 
characters by taking a&sdot;x + b (mod n), where the GCD(a, n) = 1, for each 
plaintext character x. n is the size of the alphabet you are using. So if you 
are using lowercase letters as your alphabet n = 26 and a = 0, b = 1, etc.

Here's a flag encrypted with the Affine Cipher

## The RSA Algorithm

## Factorization Attacks

**N's Share a Factor**

**Fermat's Factorization Algorithm** 

## Mathematical Attacks

#### Unknown N 
You can't crack RSA if you don't know the modulus ... right?? 

#### Common Modulus  






