# Class 5 RSA

## Overview

RSA is our first asymmetric key encryption algorithm, meaning the key used for encryption is different than the key used for decryption. In order to encrypt/decrypt with RSA and pull off the various attacks on this algorithm, we need to be comfortable with modular arithmetic in python first. 


## Modular Arithmetic
**A Note on Notation**  
> &#8484; refers to the set of integers.
>
> &#8477; refers to the set of real numbers.

**Quotient Remainder Theorem** 
> For every integer a and every positive integer b, there exists
> q,r &isin; &#8484; such that 
>
> a = b&sdot;q + r  0 &le; r &lt; b.
> So when we take a (mod b), we get r. 

#### Arithmetic Properties 
**Addition of two integers (mod n)**  
> a + b (mod n) &equiv; (a (mod n) + b (mod n)) (mod n) 

**Multiplication of two integers (mod n)** 

> a &sdot; b (mod n) &equiv; (a (mod n) &sdot; b (mod n)) (mod n) 

**Subtraction (or the Additive Inverse)**  
When we are dealing with real numbers, and we compute a - b, we are also doing
a + (-b). But negative numbers aren't in our range from 0 &le; x &lt; n, where
n is our modulus. If 0 &le; b &lt; n, then -b = n - b, and instead of 
subtracting we can add (-b). 

If we take n = 30, and we take powers of 29 (mod n), what pattern do you see? 
 
#### Multiplicative Inverse, GCD, and Euler's Totient Function 
The Greatest Common Divisor (GCD) 
> The GCD(a, b) a, b &isin; &#8484; is the largest integer that divides 
> both a and b. 

To calculate the GCD in python we can use 
```python 
#this is a must have when doing a Crypto Challenge
from Crypto.Util.number import *
a = 6
b = 2 
print(GCD(a, b)) 
> 2
```
The calculation of the GCD using this function is done in O(log(N)) time, where
N is the size of the number (in bits). This fact is extremely powerful since 
RSA uses massive numbers, and we have a very finite amount of time to 
crack these CTF problems. 

Here's a fact about the GCD of two numbers. 
> For a, b &isin; &#8484; we can find x,y &isin; &#8484; such that 
> 
> x&sdot;a + y&sdot;b = GCD(a, b) 

This fact matters to calculating the multiplicative inverse of a mod n. This 
inverse, which we will call s, is a number such that 
> s&sdot;a &equiv; 1 (mod n). 

 
Now, suppose we have integers a and b, and the GCD(a, b) = 1. 

We can then find x and y that satisfies
> x&sdot;a + y&sdot;b = 1

Now, what's the inverse of a mod b? 

We take both sides of our equation mod b. 

> x&sdot;a (mod b) + y&sdot;b (mod b) &equiv; 1 (mod b) 
> 
> x&sdot;a (mod b) + 0 &equiv; 1 (mod b) 
> 
> x&sdot;a &equiv; 1 (mod b) 
> 


So x is our inverse! 

Okay, so how do we compute it in python? 

```python 
from Crypto.Util.number import *
a = 7 # the number we want to find the inverse of  
b = 30 # our modulus 
print(inverse(7, 30)) 
> 13
a = 6
b = 12 
print(inverse(6, 12)) 
> 1 # ??? Why is this the case???  
```

##### The inverse only exists if GCD(a, b) == 1.

What is Euler's Totient Function? 
> Euler's Totient Function, denoted by &Phi;(n), is how many numbers less than
> n that are relatively prime to n. 

What does relatively prime mean? 
> Two numbers are relatively prime if they share no common factors, so their 
> GCD is 1

In RSA, we will mainly be concerned about &Phi;(n) where n is a prime, and 
the there are n - 1 integers less than n that do not share a factor with 
n. 

So &Phi;(n) = n - 1

Also &Phi;(p&sdot;q) = (p - 1)&sdot;(q - 1), when p and q are prime.  

**Euler's Theorem** 
> For any integer a, a<sup>&Phi;(n)</sup> (mod n) = 1

^^^This is huge, it's the reason that RSA works!

### Modular Arithmetic Challenge: Crack the Affine Cipher
The Affine Cipher is a function that maps plaintext characters to ciphertext 
characters by taking a&sdot;x + b (mod n), where the GCD(a, n) = 1, for each 
plaintext character x. n is the size of the alphabet you are using. So if you 
are using lowercase letters as your alphabet n = 26 and a = 0, b = 1, etc.

Here's a flag encrypted with the Affine Cipher

## The RSA Algorithm
1. Choose two large primes p and q, the choice of primes is important 
2. Calculate N = p&sdot;q and &Phi; = (p - 1)(q - 1) 
3. Choose an exponent e, such that GCD(e, &Phi;) = 1. This is usually 65537
4. Calculate your decryption exponent d = e<sup>-1</sup> (mod &Phi;) 
5. Your public key is (N, e) which you publish to the world
6. d is your private key, never publish that (or any of p, q, and &Phi;)!

To encrypt your plaintext, p, you first convert p to an integer. Then the  
ciphertext, c = p<sup>e</sup> (mod n).

To decrypt a ciphertext c, when you have d, p = c<sup>d</sup> (mod n), then
convert p to a string. 

Now send and decrypt over slack, with this key!
```python 
print(key.e)
>65537
print(key.n) 
>29359811613397007574558901494007495024500638074008326447708008686425673873040346537662141537852948628349554570991499080739677853555138698487858831610945995024103005468338256151495443858415704986082951207002437927043250802725820386382812371017230394565329200694105609744616878646984365695362850103972002440979600646849269864515666528974745286390185132954013285292402844572688817077622438171778181800923478972431326774543249348514354332977028054834143160302951704574746604221598514147162500769159006741943101426601899335724365197578242662825728340401511893964669437609312280908078206256084762105400349293541580200875169
print(key.p) 
>171081891552396781517425870379421365395996353157512195712415130944009153448948532990032058896393468721053757431857084234218366147943684743415298868393719355687115800744683653519289491294191191539616008294790894782860986912701016940865167749511667887340785261680808697804086579288990990758523644308343561674377
print(key.q) 
>171612619821923459550460428511968935293586125775342679104227666866187494435544172322613236177267379461133976157121048975501875092559454776920102021461130464508334410743518241387850778585937279043697410447318918595573226315977296155623476869402100632174445498386980319466362263241385351687682486559282254167897
```
## Factorization Attacks

**N's Share a Factor**
If we are given multiple moduli, it's a good idea to check the GCD of the
modulus, to see common factors. Since GCD is O(log(N)) complexity checking for 
common factors is MUCH faster than manual factoring! 

Related Challenge: 

**Fermat's Factorization Algorithm** 
```python 

```
## Mathematical Attacks

#### Unknown N 
You can't crack RSA if you don't know the modulus ... right?? 

#### Common Modulus  






